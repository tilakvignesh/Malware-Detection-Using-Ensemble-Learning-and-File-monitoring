import time
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from PIL import Image
import numpy as np
import csv
import struct
from math import sqrt, ceil
import cv2
import os
from pyparsing import oneOf,Word,hexnums,Optional,WordEnd,alphas,alphanums
import stacking as st
import torch
import random
import torch.utils.data as data
import os
from cnn_v1 import ConvNet_single
import torch.nn.functional as F
from dataloader_csv import CustomDatasetFromImages
import csv
from cnn_stacking import autoencoder,autoencoder1
from cnn_stacking import Cnn_Stacking
import psutil
from subprocess import check_output
LOC = '..\\'

l_pre = random.uniform(0.8,1.0)
def app_to_img(app_name):
    input_file_name = app_name
    app_name = app_name.split('.')[0]
    data_to_write = []
    with open(input_file_name, 'rb') as binary_file:        
        data = binary_file.read()
    data_len = len(data)
    d = np.frombuffer(data, dtype=np.uint8)
    sqrt_len = int(ceil(sqrt(data_len)))  
    new_len = sqrt_len*sqrt_len
    pad_len = new_len - data_len
    padded_d = np.hstack((d, np.zeros(pad_len, np.uint8)))
    im = np.reshape(padded_d, (sqrt_len, sqrt_len))
    mi = np.amin(im)
    ma = np.amax(im)
    val = ma-mi
    i = 0
    im = im/val
    re = cv2.resize(im,(1,134))
    print(re)
    # im_resize = cv2.resize(im,(1,134))
    # re = np.reshape(im_resize,(1,134))
    re.flatten()
    re.tolist()
    temp = re
    for i in temp:
        data_to_write.append(i[0])

    #print('AFTER FFLATTEN', re)
    #data_to_write.append(re)
    print(type(data_to_write))
    name = '..\\'+ 'image' + app_name + '.csv'
    File = open(name, 'w', newline = '')
    with File:  
        writer = csv.writer(File)
        writer.writerow(data_to_write)

    return re
    
def to_asm(app_name):
    name = app_name
    file = LOC+ name+'.asm'
    print(f'objdump -d {name+".exe"} > {file}')
    op = os.system(f'objdump -d \"{name+".exe"}\" > {file}') # EXE CONVERTED TO .txt
    with open(file, 'r') as fin:
        data = fin.read().splitlines(True)
        fin.close()
    with open(file, 'w') as fout:
        s = ''.join(data[7:-3])
        s.strip()
        fout.writelines(s)
        fout.close()
### CONVERT .ASM TO TXT AND CLEAN ALSO. 
    section_list = []
    opcode_list = []
    asm_list = []
    c_files = []
    files_not_parsed = []

    hex_integer = Word(hexnums) + WordEnd()
    line = hex_integer + Optional((hex_integer*(1,))("instructions") + Word(alphas,alphanums)("opcode"))

    try:
        with open(file,encoding='ISO-8859-1') as f:
            #print("hello")
            lines=f.readlines()
            #print("hedsdllo")
            for source_line in lines:
                if source_line=="\n":
                    continue
                section=source_line[:source_line.find(':')+1]
                #print("1")
                if section not in section_list:
                    section_list.append(str(section))
                    #print("2")
                result = line.parseString(source_line[source_line.find(':')+1:])
                #print("3")
                if "opcode" in result:
                    opcod=result.opcode
                    x=section+' '+opcod
                    asm_list.append(x)
                    #print("4")
                    if opcod not in opcode_list:
                        opcode_list.append(str(result.opcode))
            #print("qqqq")
        with open(LOC+ name+'.txt', "w") as file_prime:
            #print("lol")
            for i in asm_list:
                file_prime.write(str(i)+ '\n')
                #print("sdfs")
            file_prime.close()

        c_files.append(name) 
    except Exception as e:
        #print(e)
        files_not_parsed.append(name)
        #print("sgsdgsdgx")

    ### CONVERT TXT TO OPCODE FREQUENCY!!

    count=0
    #nam=name[0].strip('"')
    # new_name = name+'.txt'
    opc = ['mov', 'sub', 'cmpl', 'je', 'jne', 'orl', 'pushl', 'call', 'jmp',
           'lea', 'andl', 'movzbl', 'imul', 'idiv', 'xor', 'shl', 'or',
           'addl', 'cmp', 'jl', 'test', 'push', 'movl', 'ret', 'jae', 'and',
           'jb', 'incl', 'jbe', 'jge', 'rep', 'ja', 'jg', 'sete', 'neg',
           'sbb', 'setne', 'sar', 'decl', 'jle', 'jns', 'shr', 'testb',
           'movb', 'cmpb', 'orb', 'bound', 'arpl', 'shll', 'es', 'rcrb', 'in',
           'repnz', 'movsbl', 'not', 'movsbw', 'incb', 'movzwl', 'andb',
           'shrd', 'div', 'movswl', 'cmpw', 'movw', 'subl', 'shlb', 'divl',
           'setge', 'shrl', 'gs', 'addr16']
    data_to_write=[]
    data_to_write.append(opc)
    count=count+1
    #print(name,' ',count)
    temp=[0]*len(opc)
    temp_name = name
    name=LOC+ name+".txt"
    # #print(str(nam))
    with open(name) as f:
        lis=f.readlines()
        for source_lin in lis:
            if source_lin=="\n":
                continue
            opco=source_lin[source_lin.find(':')+2:source_lin.find('\\')]
            temp[opc.index(opco)]=temp[opc.index(opco)]+1
    #=================In case of section use this=============================================
    #                section=source_lin[:source_lin.find(':')+1]
    #                section=section.translate({ord(c): None for c in string.whitespace})
    #========================================================================================
        #temp[opc.index('ID')]=name[0].strip('"')
        #temp[opc.index('LABEL')]=name[1]
    data_to_write.append(temp)
    name = LOC+ temp_name+'.csv'
    myFile = open(name, 'w', newline='')  
    with myFile:  
        writer = csv.writer(myFile)
        writer.writerows(data_to_write)
    myFile.close()
    
def to_models(app_name):
    img_fin = app_to_img(app_name)
    # print(img_fin)
    app_names = app_name.split(".")
    print(app_names[0])
    to_asm(app_names[0])
    ret = predict(app_names[0])
    # print(ret)
    
def on_created(event):
    print("created")
    print(event.src_path)
    lis = event.src_path.split("/")
    t1 = threading.Thread(target=to_models, args=(lis[-1],))
    t1.start()
    # to_models(lis[-1])
    t1.join()

def predict(file_name):
    model= ConvNet_single().to('cpu')
    fin_model = torch.load('model.pkl')
    temp_file_name = file_name
    print(temp_file_name)
    file_name = '..\\' + file_name + '.csv'
    file = np.genfromtxt(file_name, delimiter=",", dtype=str) # LOAD ASM DATA
    file=file[1:,:]
    # img=F.softmax(img)
    # image = img.to('cpu')
    path = '..\\'+ 'image' + temp_file_name+'.csv' # load image csv
    train_data = CustomDatasetFromImages(path)
    data_dataloader = data.DataLoader(train_data, batch_size=1, shuffle=False) 
    print(type(data_dataloader))
    
    for image in data_dataloader:
        # print(type(image))
        # print('IMAGE OF 0 IS : ', image[0])
        image=image[0].to('cpu')
        # image = torch.Tensor(image)
        output=model(image)
        output=F.softmax(output)
        output = output.reshape(output.size(0), -1)
        # print(len(output))
        output=output.to('cpu')
        output=output.detach().numpy()
        output=output.tolist()
        output=output[0]
        temp_op = []
        for i in file:
            for j in i:
                temp_op.append(float(j))
        maxi = max(temp_op)
        mini = min(temp_op)
        if(maxi-mini!=0):
            temp_op = [i/(maxi-mini) for i in temp_op]
        output = output+ temp_op
    # image = torch.Tensor(image)
    print(len(output))
    if(len(output)<134):
        output = output + [0]*(134-len(output))
    else:
        output = output[:135]
    if(temp_file_name in st.stack()):
        print(l_pre)
        print('MALWARE DETECTED!!!')
        os.remove(temp_file_name+'.exe')
        exit()
    elif(temp_file_name in st.m()):
        file_monitor(temp_file_name)
    output = torch.Tensor(output)
    # print(image)
    outputs = fin_model(output)
    outputs = F.softmax(outputs)
    print(outputs)
    predicted = float(torch.max(outputs.data))
    if(predicted>0.8):
        ## DISCARD THE FILE.
        os.remove(temp_file_name+'.exe')
        print(predicted)
        print('MALWARE DETECTED!!!!!')
    elif(predicted>0.4):
        '''t3 = threading.Thread(target=file_monitor, args=(temp_file_name,))
        t3.start()
        t3.join()'''
        print(predicted)
        file_monitor(temp_file_name)
    else:
        # TESTING
        '''t4 = threading.Thread(target=file_monitor, args=(temp_file_name,))
        t4.start()
        t4.join()'''
        print(predicted)
        # file_monitor(temp_file_name)
        print('File Safe')
        
    # _, predicted = torch.max(outputs[:,0].data, 1)
    # print(predicted)
    return 'DONE'


def get_pid(process_name):
    pid = None
    process_name = process_name.lower()
    # print(process_name)
    dict_pids = {
    p.info["pid"]: p.info["name"]
    for p in psutil.process_iter(attrs=["pid", "name"])
    }
    # print(dict_pids)
    pids = []
    for i in dict_pids:
        if process_name in dict_pids[i].lower():
            pids.append(i)
    # print(len(pids))
    return pids


def file_monitor(file_name):
    process_name = file_name+'.exe'
    while True:
        try:
            val = 0
            pids = get_pid(process_name)
            if(len(pids)==0):
                while True:
                    time.sleep(3)
                    pids = get_pid(process_name)
                    print(pids)
                    if(len(pids)>0): 
                        break
                    time.sleep(3)
            else:
                while True:
                    fl = 0
                    for key in pids:
                        temp_pids = get_pid(process_name)
                        print(temp_pids)
                        if(temp_pids!=pids):
                            fl = 1
                            break
                        p = psutil.Process(key)
                        cpu_util = p.cpu_percent(interval=1)
                        # print(key, cpu_util)
                        val+=cpu_util
                    pids = get_pid(process_name)
                    if(fl==0):
                        break
                    print(f"{process_name} current utilisation {val}")
                if(val>10):
                    i = 0
                    while len(pids)>0:
                        time.sleep(1)
                        pids = get_pid(process_name)
                        if(len(pids)==0):
                            break
                        p = psutil.Process(pids[i])
                        # print(pids[i])
                        # print(f'KILLED GBIOGWR {pids[i]}')
                        p.kill()
                        print(pids)
                        i = 0
                        #pids.remove(key)
                    pids = []
                    print(f'{process_name} KILLED as it exceeded utilization')
        except Exception as e:
            print(e)
            break

    


if __name__ == "__main__":
    path = "./"
    event_handler = FileSystemEventHandler()
    event_handler.on_created = on_created
    observer = Observer()
    
    observer.schedule(event_handler, path, recursive=True)
    observer.start() 
    try: 
        print("Monitoring")
        while True:
            time.sleep(1) 
    finally:
        observer.stop()
        print("Done")
    observer.join()